use alohomora::policy::{Policy, PolicyAnd, Reason};
use tahini_tarpc::{TahiniDeserialize, TahiniSerialize};

#[derive(TahiniSerialize, TahiniDeserialize, Clone)]
pub struct AddressPolicy {
    targeted_ads: bool,
}

impl Policy for AddressPolicy {
    fn name(&self) -> String {
        "AddressPolicy".to_string()
    }

    fn join(
        &self,
        other: alohomora::policy::AnyPolicy,
    ) -> Result<alohomora::policy::AnyPolicy, ()> {
        if other.is::<Self>() {
            self.join_logic(other.specialize::<Self>().unwrap())
                .map(|p| p.into_any())
        } else {
            Ok(PolicyAnd::new(self.clone(), other).into_any())
        }
    }

    fn join_logic(&self, other: Self) -> Result<Self, ()>
    where
        Self: Sized,
    {
        Ok(Self {
            targeted_ads: self.targeted_ads && other.targeted_ads,
        })
    }

    //Could invoke some ad-specific context, that could be generated by the ad service,
    //idk if that's the right move.
    fn check(
        &self,
        _context: &alohomora::context::UnprotectedContext,
        reason: alohomora::policy::Reason<'_>,
    ) -> bool {
        match reason {
            Reason::Response => true,
            Reason::Custom(purpose) => match purpose.cast().downcast_ref::<AddressPurpose>() {
                None => false,
                Some(p) => match *p {
                    AddressPurpose::Advertisement => true,
                },
            },
            _ => false,
        }
    }
}

pub enum AddressPurpose {
    Advertisement,
}
